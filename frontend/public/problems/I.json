{
    "tests": [{
            "result": "",
            "include": false,
            "in": "3\n4\n(2 + 10 * 4) / 2\n(2 + 36) / 2\n38 / 2\n19\n\n7\n9 + (2 * (1 - 0) + 3 * (5 – 6))\n9 + (2 * 1 + 3 * (5 – 6))\n9 + (2 * 4 * (5 – 6))\n9 + (2 * 4 * -1)\n9 + (8 * -1)\n9 + -8\n1\n\n3\n7 + -2 * 3\n7 + -6\n1\n",
            "out": "1 3\n2 5\n0 0"
        },
        {
            "result": "",
            "include": false,
            "in": "7\n8\n2 + (2 * 4 - (1 + 3)) * 3 / 2 - 5\n2 + (2 * 4 - 4) * 3 / 2 - 5\n2 + (8 - 4) * 3 / 2 - 5\n2 + 4 * 3 / 2 - 5\n2 + 12 / 2 - 5\n14 / 2 - 5\n7 - 5\n2\n\n4\n(2 + 8 * 4) / 2\n(2 + 36) / 2\n38 / 2\n19\n\n5\n2 + ((5 - 6) * 3 + 2)\n2 + ((5 - 6) * 5)\n2 + (-1 * 5)\n2 + -5\n-3\n\n5\n2 + ((5 - 6) * 3 + 2)\n2 + (-1 * 3 + 2)\n2 + (-3 + 2)\n2 + -1\n1\n\n3\n1 + 2 * 1\n3 * 1\n3\n\n3\n1 + 2 * 1\n1 + 2\n3\n\n3\n1 + 1 * 1\n1 + 1\n2\n",
            "out": "5 0\n1 3\n1 9\n0 0\n1 0\n0 0\n0 0"
        },
        {
            "result": "",
            "include": false,
            "in": "1\n5\n(2 + 2) * -2 -2 -2\n4 * -2 -2 -2\n-8 -2 -2\n-8 -4\n-12\n",
            "out": "3 2"
        }
    ],
    "pid": "I",
    "description": "### Problem Description\n\nJimothy wants to test his digital calculator; however, he's a bit lazy. He decides to get Lemme to help him test it. The only problem is that Lemme is terrible at math. Lemme's \"test cases\" for Jimothy's calculator consist of simple arithmetic problems that use addition, subtraction, multiplication, and division of integers. Lemme writes down all the steps to solve each problem. Unfortunately, much of Lemme's work contains errors.\n\nTo solve this problem, **write a program that reads the evaluation steps of an arithmetic expression and identifies the location of the mathematical error (if an error exists).**\n\nLemme isn't a *terrible* helper; Jimothy can expect the following from any test cases Lemme writes out:\n\n - Lemme never makes more than one error in an entire problem's work.\n - The only types of errors that can be made are:\n   - Calculation error: when a part of the arithmetic expression is miscalculated. (e.g., if `2 * 12` is evaluated to 28, instead of 24)\n   - Order of Operations error: when the next step *should* be to evaluate one part of the expression (or “subexpression”), but a different subexpression is evaluated instead.\n\nJimothy's calculator can handle Order of Operations, so Lemme's work should follow Order of Operations... Evaluate different types of subexpressions in the following order:\n1. First, evaluate subexpressions inside parentheses, evaluating the “deepest” (innermost) pair of parentheses first.\n2. Then, evaluate multiplication and division.\n3. Finally, evaluate addition and subtraction.\n\nSubexpressions of the same type and at the same “depth” should be evaluated from left-to-right. (e.g., in the expression `2 * 6 / 3 * 8`, the subexpression `2 * 6` should be evaluated first)\n\nThe program should output the line and token number where the error occurs (using zero-based indexing). Tokens are individual parentheses, operators, or numbers. For example, the expression `(2 + 10 * 4) / 2` has the following 9 tokens:\n\n|<!-- -->|<!-- -->|<!-- -->|<!-- -->|<!-- -->|<!-- -->|<!-- -->|<!-- -->|<!-- -->|<!-- -->|\n|---|---|---|---|---|---|---|---|---|---|\n|Token Index: |0|1|2|3|4|5|6|7|8|\n|Token: |`(`|`2`|`+`|`10`|`*`|`4`|`)`|`/`|`2`|\n\nAs a complete example, consider the evaluation steps shown below:\n\n```\nLine 0:\t  (2 + 10 * 4) / 2\nLine 1:\t  (2 + 36) / 2\nLine 2:\t  38 / 2\nLine 3:\t  19\n```\n\nThe error is a calculation error: the subexpression `10 * 4` should evaluate to 40, not 36. The program should therefore identify that an error occurred at line 1, token 3 (the location of the underlined token: `36`).\n\n## Writing Your Solution\nEnter your solution in the body of this method in the given code skeleton:\n\n### Method Signature\n\n - `tokens` provides all input lines for a test case, accessed with: `tokens[lineIndex][tokenIndex]`\n - Return the `errorLineIndex` and `errorTokenIndex`. If no errors occur in the input, return `0` for both of these outputs.\n\n#### Java\n```public static int[] identifyError(String[][] tokens)``` returning an `int` array: `{errorLineIndex, errorTokenIndex}`\n\n#### Python\n```def identifyError(tokens):``` returning a tuple: `(errorLineIndex, errorRowIndex)`\n\n### Sample Method Calls\n\n#### Java\n```\nidentifyError(new String[][] {\n\tnew String[] { \"(\", \"2\", \"+\", \"10\", \"*\", \"4\", \")\", \"/\", \"2\" },\n\tnew String[] { \"(\", \"2\", \"+\", \"36\", \")\", \"/\", \"2\" },\n\tnew String[] { \"38\", \"/\", \"2\" },\n\tnew String[] { \"19\" } });\n```\nreturns an `int` array containing `{ 1, 3 }` because a calculation error occurs at line 1, token 3.\n\n```\nidentifyError(new String[][] {\n\tnew String[] { \"7\", \"+\", \"-2\", \"*\", \"3\" },\n\tnew String[] { \"7\", \"+\", \"-6\" },\n\tnew String[] { \"1\" } });\n```\nreturns an `int` array containing `{ 0, 0 }` because no mathematical error occurred in the input steps.\n\n#### Python\n```\nidentifyError([\n\t[\"(\", \"2\", \"+\", \"10\", \"*\", \"4\", \")\", \"/\", \"2\"],\n\t[\"(\", \"2\", \"+\", \"36\", \")\", \"/\", \"2\"],\n\t[\"38\", \"/\", \"2\"],\n\t[\"19\"] ]);\n```\nreturns `(1, 3)` because a calculation error occurs at line 1, token 3.\n\n```\nidentifyError([\n\t[\"7\", \"+\", \"-2\", \"*\", \"3\"],\n\t[\"7\", \"+\", \"-6\"],\n\t[\"1\"] ]);\n```\nreturns `(0, 0)` because no mathematical error occurred in the input steps.\n\n## Testing Your Program from the Console\n### Console Input Format\nInput consists of a number of test cases. The input begins with one line containing the number of test cases that will follow, `numCases`. For each test case, the input proceeds as follows:\n - a line containing the number of evaluation lines that will follow as input, `numLines`\n - on each line, a single line of the arithmetic evaluation, progressing one step further from the previous line\n   - any amount of whitespace may separate the tokens of a line\n   - no “extra” parentheses tokens will be included:\n     - no parentheses will occur around an isolated number, e.g. `1 + (4) * 8`\n     - no double parentheses will occur, e.g. `2 * ((3 + 4))`\n     - no parentheses will occur around an entire evaluation line, e.g. `(2 + 4 * 8)`\n   - zero will never have a negative sign in front of it, e.g. `4 + -0 * 5`\n - a blank line at the end of each test case\n\n\n### Assumptions\n - 1 <= `numCases` <= 10\n - 2 <= `numLines` <= 100\n - individual tokens will be integers between -1000 and 1000, inclusive\n - expressions will never contain a “divide by zero” subexpression – that is, there will never appear a subexpression `X / 0`, where X is any number\n - The following very special subexpressions will never appear in any part of input expressions:\n   - `1 * 1 * 1`\n   - `1 / 1 / 1`\n   - `0 * 0 * 0`\n   - `0 + 0 + 0`\n   - `0 - 0 - 0`\n\n### Console Output Format\n - for each test case, a single line containing the line index and token index (both zero-based) of the error in the arithmetic evaluation, space-separated\n   - if a test case has no mathematical error, output a line index and token index of zero\n\n### Sample Run\n#### Input:\n```\n3\n4\n(2 + 10 * 4) / 2\n(2 + 36) / 2\n38 / 2\n19\n\n7\n9 + (2 * (1 - 0) + 3 * (5 – 6))\n9 + (2 * 1 + 3 * (5 – 6))\n9 + (2 * 4 * (5 – 6))\n9 + (2 * 4 * -1)\n9 + (8 * -1)\n9 + -8\n1\n\n3\n7 + -2 * 3\n7 + -6\n1\n```\n\n#### Output:\n```\n1 3\n2 5\n0 0\n```\n\n### Sample Run Explanation\nThe sample run has 3 test cases.\n\nThe first test case has 4 lines of evaluation. A calculation error occurs on line 1 at the token `36` (token index 3). The subexpression `10 * 4` in line 0 should’ve evaluated to 40, not 36.\n\nThe second test case has 6 lines of evaluation. An Order of Operations error occurs on line 2 at the token `4` (token index 5). This error occurred because the subexpression `1 + 3` was evaluated before the higher priority subexpression `5 – 6`. The latter should’ve been evaluated first because it lies within a deeper set of parentheses.\n\nThe third test case contains no calculation or Order of Operations errors, so \"0 0\" is printed.\n",
    "id": "I",
    "name": "Calculator",
    "skeletons": [{
            "language": "python",
            "file_name": "Calculator.py",
            "source": "import re\nimport sys\n\ndef is_operator(token):\n\treturn token in ['+', '-', '*', '/']\n\ndef identifyError(tokens):\n\t\"\"\"\n\tTODO: Implement your routine to read the evaluation steps\n\tof an arithmetic expression and identify the location of\n\tthe mathematical error, if any.\n\t\n\tParameters:\n\tparam tokens, 2D String Array of tokens\n\t\n\tReturns:\n\terrorLineIndex, errorTokenIndex, the line and token index of the error\n\t\"\"\"\n\n\treturn (0, 0)\n\n\n# It is unnecessary to edit the \"main\" function of each problem's provided code skeleton.\n# The main function is written for you in order to help you conform to input and output formatting requirements.\ndef main():\n\tcases = int(input())\n\tfor _ in range(cases):\n\t\t# User Input #\n\t\tnum_lines = int(input())\n\t\ttokens = []\n\t\tfor i_line in range(num_lines):\n\t\t\t# split the line into tokens by using regex to match the space inbetween tokens\n\t\t\tline = input()\n\t\t\tline = re.sub('\\\\s+|(?<=[0-9\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])(?=[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])|(?<=[\\\\+\\\\*\\\\/\\\\(\\\\)])(?=[0-9\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])|(?<=[0-9]\\\\-)(?=[0-9\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])', ' ', line)\n\t\t\ttokens.append(line.strip().split(' '))\n\t\t\t\n\t\t\t# check for the one case the regex fails to catch: negative sign versus minus sign (e.g. \"1 * -1\" should have \"-1\" be a token, but \"1 -1\" should have \"-\" and \"1\" be separate tokens)\n\t\t\tfailures_fixed = 0\n\t\t\tfor i_token in range(len(tokens[i_line]) - 1):\n\t\t\t\tif (not is_operator(tokens[i_line][i_token + failures_fixed])) and (tokens[i_line][i_token + failures_fixed] != '(') and (not is_operator(tokens[i_line][i_token + 1 + failures_fixed])) and (tokens[i_line][i_token + 1 + failures_fixed] != '(') and (tokens[i_line][i_token + 1 + failures_fixed][0] == '-'):\n\t\t\t\t\t# perform correction\n\t\t\t\t\ttokens[i_line][i_token + 1 + failures_fixed] = tokens[i_line][i_token + 1 + failures_fixed][1:]\n\t\t\t\t\ttokens[i_line].insert(i_token + 1 + failures_fixed, '-')\n\t\t\t\t\tfailures_fixed += 1\n\n\t\t# Function Call\n\t\terror_location = identifyError(tokens)\n\n\t\t# Terminal Output #\n\t\tprint('{} {}'.format(error_location[0], error_location[1]))\n\n\t\ttry:\n\t\t\tinput()\n\t\texcept EOFError:\n\t\t\tpass\nmain()\n"
        },
        {
            "NewValue1": "PracticeProblem.java",
            "language": "java",
            "source": "import java.util.Scanner;\n\npublic class Calculator {\n\n\t/* It is unnecessary to edit the \"main\" method of each problem's provided code skeleton.\n\t * The main method is written for you in order to help you conform to input and output formatting requirements.\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner kb = new Scanner(System.in);\n\t\tint cases = kb.nextInt();\n\t\tkb.nextLine();\n\n\t\tfor (; cases > 0; cases--) {\n\t\t\tint lines = kb.nextInt();\n\t\t\tkb.nextLine();\n\t\t\tString[][] tokens = new String[lines][];\n\t\t\tfor (int line = 0; line < lines; line++) {\n\t\t\t\t// split the line into tokens by using regex to match the space inbetween tokens\n\t\t\t\ttokens[line] = kb.nextLine().split(\n\t\t\t\t\t\t\"\\\\s+|(?<=[0-9\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])(?=[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])|(?<=[\\\\+\\\\*\\\\/\\\\(\\\\)]|[0-9]\\\\-)(?=[0-9\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)])\");\n\t\t\t\t\n\t\t\t\t// check for the one case the regex fails to catch: negative sign versus minus sign (e.g. \"1 * -1\" should have \"-1\" be a token, but \"1 -1\" should have \"-\" and \"1\" be separate tokens)\n\t\t\t\tArrayList<String> tokensList = null;\n\t\t\t\tint failuresFixed = 0;\n\t\t\t\tfor (int iToken = 0; iToken < tokens[line].length - 1; iToken++)\n\t\t\t\t\tif (!isOperator(tokens[line][iToken]) && !tokens[line][iToken].equals(\"(\") && !isOperator(tokens[line][iToken + 1]) && !tokens[line][iToken + 1].equals(\"(\") && tokens[line][iToken + 1].charAt(0) == '-') {\n\t\t\t\t\t\t// perform correction\n\t\t\t\t\t\tif (failuresFixed == 0) tokensList = new ArrayList<String>(Arrays.asList(tokens[line]));\n\t\t\t\t\t\ttokensList.set(iToken + 1 + failuresFixed, tokens[line][iToken + 1].substring(1));\n\t\t\t\t\t\ttokensList.add(iToken + 1 + failuresFixed, \"-\");\n\t\t\t\t\t\tfailuresFixed++;\n\t\t\t\t\t}\n\t\t\t\tif (failuresFixed > 0)\n\t\t\t\t\ttokens[line] = tokensList.toArray(new String[0]);\n\t\t\t}\n\t\t\tint[] errorLocation = identifyError(tokens);\n\t\t\tSystem.out.printf(\"%d %d\\n\", errorLocation[0], errorLocation[1]);\n\t\t}\n\t\tkb.close();\n\t}\n\n\t/* TODO: Implement your routine to read the evaluation steps\n\t * of an arithmetic expression and identify the location of\n\t * the mathematical error, if any.\n\t * @param tokens, 2D String Array of tokens\n\t * @return errorLineIndex, errorTokenIndex, the line and token index of the error\n\t */\n\tpublic static int[] identifyError(String[][] tokens) {\n\t\tint errorRow = 0;\n\t\tint errorTokenIndex = 0;\n\n\t\treturn new int[] { errorRow, errorTokenIndex };\n\t}\n}\n",
            "file_name": "Calculator.java"
        }
    ],
    "division": "blue"
}